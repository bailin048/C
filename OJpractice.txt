LeetCode【1】:https://leetcode-cn.com/problems/two-sum/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int left = 0;
    int right = 0;
    *returnSize = 2;
    int *res = (int *)malloc(sizeof(int)*2);
    for(left = 0;left<numsSize-1;left++){
        for(right=left+1;right<numsSize;right++){
           if(target - nums[left] == nums[right] )
           {
               res[0] = left,res[1] = right;
               return res; 
           }
        }
    }
    return res;
}

LeetCode【27】：https://leetcode-cn.com/problems/remove-element/
int removeElement(int* nums, int numsSize, int val){
    int k = 0,i;
	for (i = 0; i < numsSize; i++) {
		if (nums[i] != val) { //不等的数字覆盖
			nums[k++] = nums[i];
		}
	}
	return k;
}

LeetCode【709】:https://leetcode-cn.com/problems/to-lower-case/
char * toLowerCase(char * str){
    int len = strlen(str);      
    char* dst = (char*)malloc(len + 1);
    char* st = dst;   //保存起始位置
    if (NULL != dst) {
        memset(dst, '\0', len + 1); 
        while (*str) {
            if ((*str >= 'A') && (*str <= 'Z')) {  //只将大写转小写
                *dst = *str + 32;
            }
            else {
                *dst = *str;
            }
            str++;
            dst++;
        }
    }
    return st;
}

LeetCode【189】:https://leetcode-cn.com/problems/rotate-array/
void Reverse(int* nums, int start, int end)
{
    while (start < end) {
        int tmp = nums[end];
        nums[end] = nums[start];
        nums[start] = tmp;
        end--, start++;
    }
}
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    Reverse(nums, 0, numsSize - 1);
    Reverse(nums, 0, k - 1);
    Reverse(nums, k, numsSize - 1);
}

LeetCode【35】:https://leetcode-cn.com/problems/search-insert-position/
int searchInsert(int* nums, int numsSize, int target){
    int left = 0;
	int right = numsSize - 1;
	int mid, flag;
	while (left <= right) {
		mid = (left + right) / 2;
		if (nums[mid] > target) {
			right = mid - 1;
			flag = 0; //说明:最后一次right减小引发的循环条件不满足,此时target>nums[right]
		}
		else if (nums[mid] < target) {
			left = mid + 1;
			flag = 1;//说明:最后一次left增大引起的循环条件不满足,此时target<nums[left]
		}
		else {
			return mid;//target存在与nums中且被找到
		}
	}
	return  flag == 0 ? right + 1 : left; //target比nums[left-1]大，但比nums[left]小，所以插的位置就是left
}

LeetCode【383】:https://leetcode-cn.com/problems/ransom-note/
bool canConstruct(char* ransomNote, char* magazine) {
    int num1[26] = {0};
    int num2[26] = {0};
    int k1 = strlen(ransomNote);
    int k2 = strlen(magazine);
    for(int i=0;i<k1;i++){
        num1[ransomNote[i]-'a']++;
    }
    for(int i=0;i<k2;i++){
        num2[magazine[i]-'a']++;
    }
    for(int i = 0;i<26;i++){
        if(num1[i]>num2[i]){
            return false;
        }
    }
    return true;
}

LeetCode【9】:https://leetcode-cn.com/problems/palindrome-number/
int LenofNum(int x)
{
    int cnt = 1;
    while (x /= 10) {
        cnt++;
    }
    return cnt;
}
int isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) { //负数及个位为0的非0数必不是回文数
        return false;
    }
    int k = LenofNum(x);
    for (int i = 0; i < k / 2; i++) {//计算一半就行
        int h = x / (int)pow(10, k - i - 1) % 10;  //获取高位数字
        int l = x / (int)pow(10, i) % 10;//获取低位数字
            if (h != l) {
                return false;
            }
    }
    return true;
}

LeetCode【58】:https://leetcode-cn.com/problems/length-of-last-word/
int lengthOfLastWord(char * s){
   int len = strlen(s), lastWordLen = 0;
    if (len == 0) return 0;

    for (int i = len - 1; i >= 0; i--) {
        if (s[i] != ' ') lastWordLen++;
        if (s[i] == ' ' && lastWordLen > 0) break;
    }

    return lastWordLen;
}

LeetCode【88】:https://leetcode-cn.com/problems/merge-sorted-array/
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    m--;
    n--; 
    for (int t = nums1Size - 1; t >= 0 && n >= 0 ; t--) {
        if (m < 0) { 
            nums1[t] = nums2[n--];
        }
        else{
            nums1[t] = nums2[n] > nums1[m] ? nums2[n--] : nums1[m--];
        }
    }
}

LeetCode【217】:https://leetcode-cn.com/problems/contains-duplicate/
int Cmp(const void* a,const void* b)
{
    return *(int*)a-*(int*)b;
}
bool containsDuplicate(int* nums, int numsSize){
    if(numsSize<=1)
        return false;
    else{
        qsort(nums,numsSize,sizeof(int),Cmp);
        for(int i = 0;i<numsSize-1;i++){
            if(nums[i]==nums[i+1])
            return true;
        }
    }
    return false;
}

LeetCode【925】:https://leetcode-cn.com/problems/long-pressed-name/
bool isLongPressedName(char * name, char * typed){
    int n = strlen(name);
    int m = strlen(typed);
    int i=0,j=0;
     while (j < m) {
        if (i < n && name[i] == typed[j]) {//一样则同时后移
            i++;
            j++;
        } else if (j > 0 && typed[j] == typed[j - 1]) {//不一样，但属于长按导致1
            j++;
        } else {//不对
            return false;
        }
    }
    return i == n;
}

LeetCode【977】:https://leetcode-cn.com/problems/squares-of-a-sorted-array/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int* p =(int*)malloc(sizeof(int)*numsSize);
    int end = numsSize - 1;
    int start = 0;
    int i = end;
    while(start<=end){
        if(abs(nums[start])>=abs(nums[end]))
            p[i--] = pow(nums[start++],2);
        else
            p[i--] = pow(nums[end--],2);
    }
    *returnSize = numsSize;
    return p;
}

LeetCode【917】:https://leetcode-cn.com/problems/reverse-only-letters/
char * reverseOnlyLetters(char * S){
        int len = strlen(S);
    if (len <= 1)
        return S;
    char* str = (char*)malloc(len + 1);
    str[len] = '\0';
    char* stack = (char*)malloc(len + 1);
    int top = 0;
    int i = 0;
    while (i < len) {
        if (isalpha(S[i])) {
            stack[top++] = S[i];
        }
        i++;
    }
    i = 0;
    while (i < len) 
        str[i++] = isalpha(S[i]) ? stack[--top] : S[i];
    return str;
}

LeetCode【905】:https://leetcode-cn.com/problems/sort-array-by-parity/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortArrayByParity(int* A, int ASize, int* returnSize) {
    int left = 0;
    int right = ASize - 1;
    while (left <= right) {
        while (left<=right && !(A[left] % 2))
            left++;
        while (left<=right && A[right] % 2)
            right--;
        if (left <= right) {
            int tmp = A[left];
            A[left] = A[right];
            A[right] = tmp;
        }
    }
    *returnSize = ASize;
    return A;
}
LeetCode【724】:https://leetcode-cn.com/problems/find-pivot-index/
int pivotIndex(int* nums, int numsSize) {
    int sum = 0;
    int sumleft = 0;
    for (int i = 0; i < numsSize; i++) 
        sum += nums[i];
    for(int i = 0;i<numsSize;i++){
        if(2*sumleft+nums[i]==sum)
            return i;
        sumleft+=nums[i];
    }
    return -1;
}

LeetCode【66】:https://leetcode-cn.com/problems/plus-one/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    int * res = (int *)malloc(sizeof(int)*(digitsSize+1));
    int flag = 0;
    res[0] = 0;
    for(int i = digitsSize - 1;i>=0;i--){
        if(i==digitsSize - 1)
            res[i+1] = digits[i] + 1;
        else
            res[i+1] = digits[i]+flag;
        res[i+1]>9?(res[i+1]%=10,flag = 1):(res[i+1],flag=0);
    }
    res[0]+=flag;
    *returnSize = res[0]==0?digitsSize:digitsSize+1;
    return res[0]==0?res+1:res;
}

LeetCode【414】:https://leetcode-cn.com/problems/third-maximum-number/
int thirdMax(int* nums, int numsSize){
    if(1 == numsSize)
        return nums[0];
    else if(2 == numsSize)
        return nums[0]>nums[1]?nums[0]:nums[1];
    else{
        long first = LONG_MIN,second = LONG_MIN,third = LONG_MIN;
        for(int i = 0;i<numsSize;i++){
            if(nums[i]==third||nums[i]==second||nums[i]==first)
                continue;
            if(nums[i]>first){
                third = second;
                second = first;
                first = nums[i];
            }else if(nums[i]>second&&nums[i]<first){
                third = second;
                second = nums[i];
            }else if(nums[i]>third&&nums[i]<second)
                third = nums[i];
        }     
        return third==LONG_MIN?first:third;
    }
}

LeetCode【8】【字符串转数字】：https://leetcode-cn.com/problems/string-to-integer-atoi/
int myAtoi(char * s){
	char *ptr = s;
    int flag = 1;
    long int res = 0;
    while((*ptr) == ' ')
        ptr++;
    if(*ptr == '-'){
        flag = -1;
        ptr++;
    }else if(*ptr == '+'){
        flag = 1;
        ptr++;
    }
    while(isdigit(*ptr)){
        res=(res*10+*ptr-'0');
        if((int)res != res)
            break;
        ptr++;
    }
    if(isdigit(*ptr))
        if(flag == -1)
            return INT_MIN;
        else
            return INT_MAX;
    return res*flag;
}

LeetCode【34】【寻找目标数字的索引】：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int* res =(int*)malloc(sizeof(int)*2);
    res[0]=res[1]=-1;
    int left = 0,right = numsSize - 1;
    while(left<=right){//先找到target
        int mid = (left+right)>>1;
        if(nums[mid]>target)
            right = mid - 1;
        else if(nums[mid]<target)
            left = mid + 1;
        else{
            left = right = mid;//向两边找
            while(left - 1>=0 && !(nums[left-1]^target))
                left--;
             while(right + 1<=numsSize - 1 && !(nums[right+1]^target))
                right++;
            res[0] = left,res[1] = right;
            break;
        }
    }
    return res;
}

LeetCode【125】【验证回文字符串】:https://leetcode-cn.com/problems/valid-palindrome/
bool isPalindrome(char * s){
    int n = strlen(s);
    int left = 0;
    int right = n-1;
    while(left<=right){
        if(!isalnum(s[left])){
            left++;
            continue;
        }
        while(!isalnum(s[right])){
            right--;
            continue;
        }
        if(tolower(s[left]) != tolower(s[right]))
            return false;
        left++,right--;
    }
    return true;
}

LeetCode【443】【压缩字符串】：https://leetcode-cn.com/problems/string-compression/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
int compress(char* chars, int charsSize){
    if(charsSize<2)//不需要压缩
        return charsSize;
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&chars[follow]==chars[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = chars[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(k>1&&nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return t;
}
LeetCode【150】【根据逆波兰表示法，求表达式的值】：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
int evalRPN(char ** tokens, int tokensSize){
    int* stack = (int*)malloc(tokensSize*sizeof(int));
    int top = -1;
    int n1 = 0,n2 = 0;
    for(int i = 0;i<tokensSize;i++){
        if(!strcmp(tokens[i],"+")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 + n2; 
        }
        else if(!strcmp(tokens[i],"*")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 * n2; 
        }    
        else if(!strcmp(tokens[i],"-")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n2 - n1; 
        }     
        else if(!strcmp(tokens[i],"/")){
             n1 = stack[top--],n2 = stack[top--];
             stack[++top] = n2 / n1; 
        }
        else
            stack[++top] = atoi(tokens[i]);//字符转数字
    }
    return stack[top];
}

LeetCode【38】【外观数列】：https://leetcode-cn.com/problems/count-and-say/
char * countAndSay(int n){
    int size = 10000;
    char* strold = (char*)malloc(size);
    char* strnew = (char*)malloc(size);
    memset(strold,'\0',size),memset(strnew,'\0',size);
    strold[0] = '1';
    int cnt = 0;
    int k = 0;
    char *ptr = strold;
    while(--n){
        while(*ptr){
            cnt = 0;
            char key = *ptr;
            while(*ptr && *ptr == key)
                cnt++,ptr++;
            strnew[k++] = cnt + '0';
            strnew[k++] = key;
        }
        memcpy(strold,strnew,strlen(strnew));
        memset(strnew,'\0',strlen(strnew));
        ptr = strold;
        k = 0;
    }
    return strold;
}

【剑指Offer21】【调整数组顺序使奇数位于偶数之前】：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/
int* exchange(int* nums, int numsSize, int* returnSize){
    int left = 0,right = numsSize - 1;
    *returnSize = numsSize;
    while(left < right){
        while(left < right && nums[left]%2)
            left++;
        while(right>left && !(nums[right]%2))
            right--;
        int tmp = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
    }
    return nums;
}

LeetCode【167】【两数之和】：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(2*sizeof(int));
    res[0]=-1,res[1]=-1;
    int left = 0,right = numbersSize - 1;
    while(left<right){
        if(numbers[left]+numbers[right]>target)
            right--;
        else if(numbers[left]+numbers[right]<target)
            left++;
        else{
            res[0]=left+1,res[1]=right+1;
            break;
        }
    }
    return res;
}

LeetCode【168】【Excel表列名称】：https://leetcode-cn.com/problems/excel-sheet-column-title/
char * convertToTitle(int n){
    int size = 10000;
    char* res = (char*)malloc(size);
    int i = 0;
    memset(res,'\0',size);
    while(n){
        n-=1;
        int c = n%26;
        res[i++] = c  + 'A';
        n/=26;
    } 
    int len = strlen(res);
    int half = len/2;
    i = 0;
    while(i<half){
        char tmp = res[len - i - 1];
        res[len - i - 1] = res[i];
        res[i] = tmp;
        i++;
    }
    return res;
}

LeetCode【171】【Excel表列序号】：https://leetcode-cn.com/problems/excel-sheet-column-number/
int titleToNumber(char * s){
    int res = 0;
    int len = strlen(s);
    int i = len - 1;
    while(i > -1){
        res += (int)(*s - 64)*(int)pow(26,i);
        s++;
        i--;
    }
    return res;
}

LeetCode【112】【路径总和】：https://leetcode-cn.com/problems/path-sum/
bool IsEuqal(struct TreeNode* root,int target,int sum){
    if(NULL == root)
        return false;
    sum += root->val;
    if(sum == target && root->left == NULL && root->right == NULL)
        return true;
    return IsEuqal(root->left,target,sum) || IsEuqal(root->right,target,sum);
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    int sum = 0;
    return IsEuqal(root,targetSum,0);
}

LeetCode【121】【买卖股票的最佳时机I】：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int buy = 0;
    int profit =0;
    int i = 0;
    while(i < pricesSize){
        buy = prices[i]<prices[buy]?i:buy;
        profit = profit>(prices[i]-prices[buy])?profit:prices[i]-prices[buy];
        i++;
    }
    return profit;
}

LeetCode【122】【买卖股票的最佳时机II】
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int profit = 0;
    for(int i = 1;i<pricesSize;i++){
        profit += fmax(0,prices[i]-prices[i-1]);
    }
    return profit;
}

LeetCode【258】【各位相加】：https://leetcode-cn.com/problems/add-digits/
int addDigits(int num){
    if(num < 10)
        return num;
    else{
        int res = 0;
        while(num){
            res += (num%10);
            num/=10;
        }
        num = addDigits(res);
        return num; 
    }
}

【剑指Offer58-II】【左旋转字符串】：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/
char* reverseLeftWords(char* s, int n){
    int len = strlen(s);
    char* res = (char*)malloc(len + 1);
    char* p = res;
    memset(res,'\0',len + 1);
    n = n % len;
    char* tmp = s + n;
    strcpy(p,tmp);
    while(*p)
        p++;
    while(n--){
        *p = *s;
        s++,p++;
    }
    return res;
}

【剑指Offer28】【对称的二叉树】：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
bool _Issymmetric(struct TreeNode* p,struct TreeNode* q)
{
    if(NULL == p && NULL == q)
        return true;
    if(NULL == p || NULL == q)
        return false;
    return (p->val == q->val) && _Issymmetric(p->left,q->right) && _Issymmetric(p->right,q->left);
}
bool isSymmetric(struct TreeNode* root){
    if(NULL == root)
        return true;
    return _Issymmetric(root->left,root->right);
}

【剑指Offer52】【两个链表的第一个公共节点】：https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* A = headA;
    struct ListNode* B = headB;
    while(A != B){
        if(A == NULL)
            A = headB;
        else
            A = A->next;
        if(B == NULL)
            B = headA;
        else
            B = B->next;
    }
    return A;
}

【剑指Offer26】【树的子结构】：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
bool IsSame(struct TreeNode* p,struct TreeNode* q){
    if(q == NULL)
        return true;
    if(p == NULL)
        return false;
    return (p->val == q->val) && IsSame(p->left,q->left) && IsSame(p->right,q->right);
}
bool isSubStructure(struct TreeNode* A, struct TreeNode* B){
    if(A == NULL || B == NULL)
        return false;
    if(IsSame(A,B))
        return true;
    return isSubStructure(A->left,B) || isSubStructure(A->right,B);
}

【剑指offer22】【链表中倒数第K个节点】：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
【方法1】
int LenofList(struct ListNode* head){
    int n = 0;
    while(head){
        head = head->next;
        n++;
    }
    return n;
}
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    int len = LenofList(head);
    if(k > len)
        return NULL;
    while(len != k){
        head = head->next;
        len--;
    }
    return head;
}
【方法2】：双指针
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    struct ListNode* pre = head;
    while(k && pre != NULL){
        pre = pre->next;
        k--;
    }
    while(pre != NULL){
        pre = pre->next;
        head = head->next;
    }
    return k==0?head:pre;
}

【LCP01】【猜数字】：https://leetcode-cn.com/problems/guess-numbers/
int game(int* guess, int guessSize, int* answer, int answerSize){
    int cnt = 0;
    for(int i = 0;i<guessSize;i++)
       cnt += (guess[i]==answer[i]?1:0);
    return cnt;
}

【LCP18】【早餐组合】：https://leetcode-cn.com/problems/2vYnGI/
void ShellInsert(int *a,int dk,int size){
    for(int i = dk;i < size;i++){
        int temp = a[i];
        int j = 0;
        for(j = i - dk;j >= 0 && temp < a[j];j-=dk)
            if(temp < a[j])
                a[j+dk] = a[j];
        a[j+dk] = temp;
    }
}
void Sort(int* a,int size){
    int dk = size;
    while(dk/=2)
        ShellInsert(a,dk,size);
}
int breakfastNumber(int* staple, int stapleSize, int* drinks, int drinksSize, int x){
   Sort(drinks,drinksSize);
   int cnt = 0;
   for(int i = 0;i < stapleSize; i++){
        int left = 0,right = drinksSize - 1,mid = 0;
        while(left <= right){
            mid = (left+right)>>1;
            int tmp = staple[i]+drinks[mid];
            if(tmp>x)
                right = mid - 1;
            else
                left = mid + 1;
        }
        cnt += left;
        cnt %= 1000000007; 
   }
   return cnt;
}

LeetCode【107】【二叉树的层序遍历】：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
int Height(struct TreeNode* root){
     if(NULL == root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r; 
 }
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = Height(root);//树深
    int** levelorder = (int**)malloc(sizeof(int*)*h);//开辟空间，存储数组指针
    *returnSize = h;//数组指针的数目 = 树深
    *returnColumnSizes =  (int *)malloc(sizeof(int)*h);//
    
    struct TreeNode*q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root;
    q1_size++;
    int level = 0;
    while(level<h){
        levelorder[h-1-level] = (int *)malloc(sizeof(int)*q1_size);
        for(int i = 0;i<q1_size;i++)
            levelorder[h-1-level][i] = q1[i]->val;
        (*returnColumnSizes)[h-1-level] = q1_size;
        for(int i = 0;i<q1_size;i++){//q1里的左右孩子存入q2，获得下一层数据
            if(q1[i]->left != NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right != NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        level++;
    }
    return levelorder;
}

LCP【16】【速算机器人】：https://leetcode-cn.com/problems/nGK0Fy/
int calculate(char* s){
    int x = 1,y = 0;
    while(*s){
        if(*s == 'A')
            x = 2*x + y;
        else
            y = 2*y + x;
        s++;
    }
    return x+y;
}

LCP【11】【期望个数统计】：https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji/
void Sort(int* scores,int num){
    int dk = num;
    while(dk/=2){
        for(int i = dk;i<num;i++){
            int tmp = scores[i];
            if(tmp<scores[i-dk]){
                int j = 0;
                for(j=i-dk;j>=0&&tmp<scores[j];j-=dk)
                    scores[j+dk]=scores[j];
                scores[j+dk] = tmp;
            }
        }
    }
}
int expectNumber(int* scores, int scoresSize){
    int cnt = 1;
    Sort(scores,scoresSize);
    for(int i = 1;i<scoresSize;i++){
        if(scores[i]!=scores[i-1])
            cnt+=1;
    } 
    return cnt;
}

LCP【06】【拿硬币】：https://leetcode-cn.com/problems/na-ying-bi/
int minCount(int* coins, int coinsSize){
    int cnt = 0;
    for(int i = 0;i<coinsSize;i++)
        cnt += coins[i]%2?(coins[i]/2+1):(coins[i]/2);
    return cnt;
}

LCP【02】【分式化简】：https://leetcode-cn.com/problems/deep-dark-fraction/
int* fraction(int* cont, int contSize, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int son = 1; //最后一分数，分子为1
    int mother = cont[contSize-1];//分母为数组最后一个元素
    int tmp = 0;//提供交换功能
    for(int i = contSize - 2;i>=0;i--){
        tmp = mother;//保存上次分母
        mother = mother*cont[i]+son;//计算新分母
        son = tmp;//分子继承tmp
    }
    res[0] = mother;//因为数组首元素计算完成后未发生分子分母交换,此处存储时反序即可
    res[1] = son;
    return res;
}

【剑指offer15】【二进制中1的个数】https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
int hammingWeight(uint32_t n) {
    int cnt = 0;
    for(int i = 0;i<32;i++){
        if((n>>i)&1)
            cnt++;
    }
    return cnt;
}

【剑指offer17】：打印从1到最大的n位数
int* printNumbers(int n, int* returnSize){
    int max = pow(10,n) - 1;
    *returnSize = max;
    int* res = (int*)malloc(sizeof(int)*max);
    for(int i = 0;i < max;i++)
        res[i] = i + 1;
    return res;
}

【LCP22】【黑白方格画】：https://leetcode-cn.com/problems/ccw6C7/
int factorail(int n,int m){
    int son = 1,mother = 1; 
    for(int k = n;k>n-m;k--)
        son*=k;
    for(int k = 1;k<=m;k++)
        mother*=k;
    return son/mother;
}
int paintingPlan(int n, int k){
    if(k==n){
        if(k==1)//n=k=1
            return 1;
        else//n==k!=1
            return 2*n;
    }
    if(k==n*n || k==0)//白板或者黑板
        return 1;
    if(k<n)//一行都画不满，不让进循环，否则浪费空间时间
        return 0;
    int cnt = 0;
    for(int i = 1;i<n;i++){
        int res = k - i*n;
        if(res>0){
            int flag = res%(n-i)==0?res/(n-i)<n?res/(n-i):0:0;
            if(flag)
                cnt+=factorail(n,i)*factorail(n,flag);
        }
        else if(res == 0)
            cnt += 2*factorail(n,i);
        else
            continue;
    }
    return cnt;
}

【剑指Offer18】【删除链表的节点】：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
struct ListNode* deleteNode(struct ListNode* head, int val){
    if(NULL == head)
        return head;
    struct ListNode* p = head;
    struct ListNode* pre = NULL;
    while(p){
        if(p->val == val && p == head)
            head = p->next;
        else if(p->val == val)
            pre->next = p->next;
        pre = p;
        p=p->next;
    }
    return head;
}

【剑指offer27】【二叉树的镜像】：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
struct TreeNode* mirrorTree(struct TreeNode* root){
    if(NULL == root)
        return NULL;
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = tmp;
    mirrorTree(root->left);
    mirrorTree(root->right);
    return root;
}

【剑指offer32】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
int height(struct TreeNode* root){
    if(NULL == root)
        return 0;
    int h_l = height(root->left)+1;
    int h_r = height(root->right)+1;
    return h_l>h_r?h_l:h_r;
 }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = height(root);
    int** res = (int**)malloc(sizeof(int*)*h);
    *returnSize = h;
    *returnColumnSizes = (int*)malloc(sizeof(int)*h);

    struct TreeNode* q1[1000],*q2[1000];
    int q1_size =0,q2_size=0;
    q1[0]=root;
    q1_size++;
    int layer = 0;
    while(layer<h){
        res[layer] = (int*)malloc(sizeof(int)*q1_size);
        for(int i= 0;i<q1_size;i++)
            res[layer][i] = q1[i]->val;
        (*returnColumnSizes)[layer] = q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left!=NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right!=NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode *)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        layer++;
    }
    return res;
}

【剑指offer42】:最大子序和
int maxSubArray(int* nums, int numsSize){
    int submax = nums[0];
    int max = nums[0];
    for(int i= 1;i<numsSize;i++){  
        if(submax<0)
            submax = nums[i];
        else  
            submax += nums[i];
        max = submax>max?submax:max; 
    }
    return max;
}

【LeetCode151】【剑指offer58】【翻转单词顺序】：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/
int len = strlen(s);
    if (len == 0)
        return s;
    char* res = (char*)malloc(len + 1);
    memset(res, ' ', len + 1);
    int i = len;
    char* pre = s;
    char* help = NULL;
    char* target = NULL;
    while (*pre) {
        while (*pre && *pre == ' ')//跳空格
            pre++;
        help = pre;//help指向单词首字母
        while (*pre && *pre != ' ')
            pre++;
        target = pre;//target指向单词右侧
        if (*pre == '\0') {//最后一个单词，pre会指向'\0'
            res[i--] = ' ';
            pre--;
        }
        while (help-1 != pre) {//后退式复制带空格
            res[i--] = *pre;
            pre--;
        }
        pre = target;//复制完成pre回到空格处，寻找下一个单词
    }
    res[len] = '\0';//原本此处被放空格
    while (*res == ' ')
        res++;
    return res;
}

LeetCode【202】【快乐数】:https://leetcode-cn.com/problems/happy-number/
int helper(int n){
    int res = 0;
    while(n){
        int tmp = n%10;
        res += tmp*tmp;
        n/=10;
    }
    return res;
}
bool isHappy(int n){
    int slow = n,fast = n;
    do{
        slow = helper(slow);
        fast = helper(helper(fast));
    }while(slow!=fast);
    return slow==1;
}

LeetCode【461】【汉明距离】：https://leetcode-cn.com/problems/hamming-distance/
int hammingDistance(int x, int y){
    int n = x^y;
    int res = 0;
    for(int i = 0;i<32;i++)
        if((n>>i)&1)
            res++;
    return res;
}

LeetCode【415】【字符串相加】：https://leetcode-cn.com/problems/add-strings/
char * addStrings(char * num1, char * num2){
    int len1 = strlen(num1);
    int len2 = strlen(num2);
    char* long_s,*short_s;
    len1>len2?(long_s = num1,short_s = num2):(long_s = num2,short_s = num1);
    len1 = strlen(long_s),len2 = strlen(short_s);
    char* res = (char*)malloc(sizeof(char)*(len1+2));//预留结束符与前导位置
    memset(res,'0',len1+2);
    res[len1+1] = '\0';
    int flag = 0;
    for(int i = len1-1;i>=0;i--){
        int tmp = 0;
        if(i-len1+len2>=0)
            tmp = flag + (long_s[i]-'0')+(short_s[i-len1+len2]-'0');
        else
            tmp = flag + long_s[i]-'0';
        res[i+1]= tmp % 10 + '0';
        if(tmp>9)
            flag = 1;
        else
            flag = 0;
    }
    if(flag == 1)
        res[0]='1';
    else 
        return res + 1;
    return res; 
}

LeetCode【412】【Fizz Buzz】：https://leetcode-cn.com/problems/fizz-buzz/
char ** fizzBuzz(int n, int* returnSize){
    int cnt = 0;
    *returnSize = n;
    char** res = (char**)malloc(sizeof(char*)*n);
    for(int i =1;i<=n;i++){
        if(i%5==0&&i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*9);
            memset(tmp,'\0',9);
            strcat(tmp,"FizzBuzz");
            res[i-1] = tmp;
        }else if(i%5==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Buzz");
            res[i-1] = tmp;
        }else if(i%3==0){
            char* tmp = (char*)malloc(sizeof(char)*5);
            memset(tmp,'\0',5);
            strcat(tmp,"Fizz");
            res[i-1] = tmp;
        }else{
            int cnt = 0;
            int num = i;
            while(num){
                cnt++;
                num/=10;
            }
            char* tmp = (char*)malloc(sizeof(char)*(cnt+1));
            memset(tmp,'\0',cnt+1);
            for(int j =0;j<cnt;j++){
                tmp[j] = i/(int)pow(10,cnt-j-1)%10+'0';
            }
            res[i-1] = tmp;
        }
    }
    return res;
}

LeetCode【434】【字符串中的单词数】：https://leetcode-cn.com/problems/number-of-segments-in-a-string/
int countSegments(char * s){
    int cnt = 0;
    char* pre = s;
    while(*pre){
        while(*pre && *pre == ' ')//越过空格
            pre++;
        while(*pre && *pre != ' ')//寻找单词后的空格
            pre++;
        if (*(pre-1)!=' ')
            cnt++;
    }
    return cnt;
}

LeetCode【441】【排列硬币】：https://leetcode-cn.com/problems/arranging-coins/
int arrangeCoins(int n){
    int cnt=0;
    for(int i=1;n>=0;i++){
        n-=i;
        cnt++;
    }
    return cnt-1;
}

LeetCode【448】【找到所有数组中消失的数字】：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){
    int* res = (int*)malloc(sizeof(int)*(numsSize/2));
    int cnt = 0;
    for(int i = 0;i<numsSize;i++){
      if(nums[abs(nums[i])-1]>0)
        nums[abs(nums[i])-1] *= -1;
    }
    for(int i = 0;i<numsSize;i++){
      if(nums[i]>0)
        res[cnt++] = i + 1;
    }    
    *returnSize = cnt;
    return res;
}

LeetCode【409】【最长回文串】：https://leetcode-cn.com/problems/longest-palindrome/
int longestPalindrome(char * s){
    int cnt[128]={0},res = 0;
    for(int i = 0;i<strlen(s);i++)
        cnt[s[i]]++;
    for(int i =0;i<128;i++)
        res += cnt[i]/2*2;
    return res<strlen(s)?res+1:res;
}

LeetCode【404】【左叶子之和】：https://leetcode-cn.com/problems/sum-of-left-leaves/
bool isleaf(struct TreeNode* root){
    return !root->left && !root->right;
}
int dfs(struct TreeNode* root){
    int ans = 0;
    if(root->left)
        ans += isleaf(root->left)?root->left->val:dfs(root->left);
    if(root->right && !isleaf(root->right))
        ans += dfs(root->right);
    return ans;
}
int sumOfLeftLeaves(struct TreeNode* root){
    return root?dfs(root):0; 
}

LeetCode【405】【数字转化为十六进制数】：https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/
char * toHex(int num){
    if(0 == num)
        return "0";
    char *s = "0123456789abcdef";
    int index = 0;
    char* res = (char*)malloc(9);
    memset(res,'0',9);
    res[8] = '\0';
    for(int i = 0;i < 8; i++)
        res[7-i] = s[((unsigned int)num>>4*i)&(0xf)];
    while(*res == '0')
        res++;
    return res;
}

LeetCode【401】【二进制手表】：https://leetcode-cn.com/problems/binary-watch/
int bitnum(int n){
     int cnt = 0;
     while(n){
        if(n&1)
            cnt++;
        n>>=1;
     }
     return cnt;
 }
char ** readBinaryWatch(int num, int* returnSize){
    *returnSize = 0;
     for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num)
                (*returnSize)++;
        }
    }
    char** res = (char**)malloc(sizeof(char*)*(*returnSize));
    int i = 0;
    for(int h = 0;h < 12; h++){
        for(int m = 0;m < 60; m++){
            int k = bitnum(h) + bitnum(m);
            if(k == num){
                res[i] = (char*)malloc(6);
                sprintf(res[i++],"%d:%02d",h,m);
            }
        }
    }
    return res;
}

LeetCode【231】【2的幂】：https://leetcode-cn.com/problems/power-of-two/
bool isPowerOfTwo(int n){
    return n > 0 && !(n & (n-1));
}

LeetCode【326】【3的幂】：https://leetcode-cn.com/problems/power-of-three/
bool isPowerOfThree(int n){
    if (n < 1)
        return false;
    while(n%3 == 0)
        n/=3;
    return n==1?true:false;
}

LeetCode【342】【4的幂】：https://leetcode-cn.com/problems/power-of-four/
bool isPowerOfFour(int n){
    if(n<1)
        return false;
    while(n%4==0)
        n/=4;
    return n==1?true:false;
}

LeetCode【371】【两整数之和】：https://leetcode-cn.com/problems/sum-of-two-integers/
int getSum(int a, int b){
    while(b!=0){
        int tmp = a^b;
        b = ((unsigned int)(a&b) << 1);
        a = tmp;
    }
    return a;
}

LeetCode【374】【猜数字大小】：https://leetcode-cn.com/problems/guess-number-higher-or-lower/
int guessNumber(int n){
	int low = 1;
    int high = n;
    while(low<=high){
        int mid = low+(high-low)/2;
        int res = guess(mid);
        if(res == 0)
            return mid;
        else if(res < 0)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}

LeetCode【389】【找不同】：https://leetcode-cn.com/problems/find-the-difference/
char findTheDifference(char * s, char * t){
    int sn[26]={0};
    int ls = strlen(s),lt = strlen(t);
    for(int i = 0;i<ls;i++)
        sn[s[i]-'a']++;
    for(int i = 0;i<lt;i++){
        sn[t[i]-'a']--;
        if (sn[t[i] - 'a'] < 0) {
            return t[i];
        }
    }
    return ' ';
}

面试题【01.01】【判定字符串是否唯一】：https://leetcode-cn.com/problems/is-unique-lcci/
bool isUnique(char* astr){
    int num[26] = {0};
    int len = strlen(astr);
    for(int i=0;i<len;i++)
        num[astr[i]-'a']++;
    for(int i=0;i<26;i++)
        if(num[i]>1)
            return false;
    return true;
}

面试题【01.02】【判定是否为字符重排】：https://leetcode-cn.com/problems/check-permutation-lcci/
bool CheckPermutation(char* s1, char* s2){
    int nums[26]={0};
    int ls1 = strlen(s1),ls2 = strlen(s2);
    for(int i = 0;i<ls1;i++)
        nums[s1[i]-'a']++;
    for(int i = 0;i<ls2;i++)
        nums[s2[i]-'a']--;
    for(int i = 0;i<26;i++)
        if(nums[i]!=0)
            return false;
    return true;
}

面试题【01.06】【字符串压缩】：https://leetcode-cn.com/problems/compress-string-lcci/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
char* compressString(char* S){
    int charsSize = strlen(S);
    int size = 100000;
    char* chars = (char*)malloc(1000001);
    memset(chars,'\0',size+1);
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&S[follow]==S[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = S[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return strlen(chars)>=charsSize?S:chars;
}

LeetCode【268】【丢失的数字】：https://leetcode-cn.com/problems/missing-number/
int missingNumber(int* nums, int numsSize){
    int tmp=0;
    for(int i = 0;i<numsSize;i++)
        tmp^=nums[i],tmp^=i;
    for(int i = 0;i<=numsSize;i++)
        tmp ^= i;
    return tmp;
}

LeetCode【242】【有效的字母异位词】：https://leetcode-cn.com/problems/valid-anagram/
bool isAnagram(char * s, char * t){
    int lens = strlen(s);
    int lent = strlen(t);
    if(lens != lent)
        return false;
    int num[26]={0};
    for(int i = 0;i<lens;i++){
            num[s[i]-'a']++;
            num[t[i]-'a']--;
    }
    for(int i = 0;i<26;i++)
        if(num[i]>0)
            return false;
    return true;
}

LeetCode【153】【寻找旋转排序数组的最小值】：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/
int findMin(int* nums, int numsSize){
    int left = 0,right = numsSize - 1;
    while(left<right){
        int mid = left+(right-left)/2;
        if(nums[mid]>nums[right])
            left = mid + 1;
        else
            right = mid;
    }
    return nums[left];
}

剑指offer/LeetCode【11/154】【旋转数组的最小数字】：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
int minArray(int* numbers, int numbersSize){
    int left = 0,right = numbersSize-1;
    while(left<right){
        int mid=left+(right-left)/2;
        if(numbers[mid]>numbers[right])
            left = mid + 1;
        else if(numbers[mid] == numbers[right])
            right--;
        else
            right = mid;
    }
    return numbers[left];
}

LeetCode【367】【有效的完全平方数】：https://leetcode-cn.com/problems/valid-perfect-square/
bool isPerfectSquare(int num){
    int i = -1;
    while(num>0){
        i+=2;
        num-=i;
    }
    return num==0?true:false;
}

剑指offer【06】【从头到尾打印链表】：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/
int* reversePrint(struct ListNode* head, int* returnSize){
    int len = 0;
    struct ListNode* p = head;
    while(p){
        p = p->next;
        len++;
    }
    *returnSize = len;
    p = head;
    int* res = (int*)malloc(sizeof(int)*len);
    for(int i = len - 1;i>=0;i--){
        res[i] = p->val;
        p = p->next;
    }
    return res;
}

剑指offer【16】【数值的整数次方】：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/
double myPow(double x, int n){
    double res = 1.0;
    long int y = (long int)n;
    if(n<0){
        x= 1.0/x;
        y=-y;
    }
    while(y){
        if(y&1)
            res*=x;
        x*=x;
        y/=2;
    }
    return res;
}

剑指offer【05】【替换空格】：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/
char* replaceSpace(char* s){
    int len = strlen(s);
    char*res = (char*)malloc(sizeof(char)*3*len+1);
    memset(res,'\0',3*len+1);
    int cnt = 0;
    for(int i = 0;i<len;i++){
        if(s[i] == ' '){
            strcat(res,"%20");
            cnt+=3;
        }
        else
            res[cnt++] = s[i];
    }
    return res;
}

剑offer【09】【用两个栈实现队列】：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/
#define NUM 10000
typedef struct {
    int *s1 ;
    int len_s1;
    int *s2;
    int len_s2;
} CQueue;

CQueue* cQueueCreate() {
    CQueue* Q = (CQueue*)malloc(sizeof(CQueue));
    Q->s1 = (int*)malloc(sizeof(int)*NUM);
    Q->s2 = (int*)malloc(sizeof(int)*NUM);
    Q->len_s1 = -1;
    Q->len_s2 = -1;
    return Q;
}

void cQueueAppendTail(CQueue* obj, int value) {
    if(obj->len_s1>=10000)
        return;
    obj->s1[++obj->len_s1] = value;
}

int cQueueDeleteHead(CQueue* obj) {
    if(obj->len_s2 == -1 && obj->len_s1 == -1)
        return;
    if(obj->len_s2 == -1){
        while(obj->len_s1 != -1)
            obj->s2[++obj->len_s2] = obj->s1[obj->len_s1--];
    }
    return obj->s2[obj->len_s2--];
}

void cQueueFree(CQueue* obj) {
    free(obj->s1);
    free(obj->s2);
    obj->s1 = NULL;
    obj->s2 = NULL;
    obj->len_s1 = -1;
    obj->len_s2 = -1;
}

剑指offer【29】【顺时针打印矩阵】：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    if(matrixSize == 0 || matrixColSize[0] == 0){
        *returnSize = 0;
        return NULL;
    }
    int all = matrixSize*matrixColSize[0];
    int* res = (int*)malloc(sizeof(int)*all);
    *returnSize = all;
    int left = 0,right = matrixColSize[0]-1 ;
    int top = 0,bottom = matrixSize-1;
    int cnt = 0;
    while(cnt<all){
        int l = left,r = right,t = top,b = bottom;
       while(cnt<all && l<=right)
           res[cnt++]=matrix[top][l++];
        t++;
        while(cnt<all && t<=bottom)
            res[cnt++]=matrix[t++][right];
        r--;
        while(cnt<all && r>=left)
            res[cnt++]=matrix[bottom][r--];
        b--;
        while(cnt<all && b>top)
            res[cnt++]=matrix[b--][left];
        left++;
        right--;
        top++; 
        bottom--;
    }
    return res;      
}

LeetCode【392】【判断子序列】：https://leetcode-cn.com/problems/is-subsequence/
bool isSubsequence(char * s, char * t){
    if(NULL == t && NULL == s)
        return true;
    if(NULL == s)
        return true;
    if(NULL == t)
        return false;
    while(*t){
        if(*t == *s)
            s++;
        t++;
    }
    return *s == '\0';
}

LeetCode【400】【第N位数字】：https://leetcode-cn.com/problems/nth-digit/
int helper(long int n){
    int cnt = 0;
    while(n>0){
        n -= 9*(long int)pow(10,cnt)*(cnt+1);
        cnt++;
    }
    return cnt;
}
int findNthDigit(int n){
    int pos = helper(n);//确定处于几位数范围
    int cnt = 0;
    while(cnt < pos - 1)//计算剩余的部分,刨去位数<pos的区间
        n-=(9*(int)pow(10,cnt++)*cnt);
    int start = (int)pow(10,pos-1);//最小的pos位数
    int count = n / pos,res = n % pos; //计算第n个数字位置之前有多少整数及余数
    int flag = res>=1?1:0; 
    int num = start + count - 1 + flag;//计算第n个数字位于哪个数字上
    res = n - (num-start)*pos; //计算位于num的第几位
    return (num/(int)pow(10,pos-res))%10;
}

LeetCode【397】【整数替换】：https://leetcode-cn.com/problems/integer-replacement/
int integerReplacement(int n){
    int cnt = 0;
    while(n>1){
        if(n == INT_MAX)//上界单独处理
            n--,n/=2,n++,cnt++;
        else if(!(n%2))//偶数
            n>>=1;
        else //奇数
            n += ((n & 2) == 0 || n == 3)?-1:1;//0x？？？？？？？[??01]及0x11减1，其他++1；
        cnt++;
    }
    return cnt;
}

LeetCode【2】【两数相加】：https://leetcode-cn.com/problems/add-two-numbers/
struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    struct ListNode* addres = NULL;
    struct ListNode* p = addres;
    int flag = 0;
    while(l1||l2){
        int n1 = l1?l1->val:0;
        int n2 = l2?l2->val:0;
        int tmp = n1 + n2 + flag;
        flag = tmp>9?1:0;
        if (!addres){
            p = addres = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->val = tmp%10;
            p->next = NULL; 
        }
        else{
            p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = tmp%10;
            p->next->next = NULL;
            p = p->next;
        }
        if(l1)
            l1=l1->next;
        if(l2)
            l2=l2->next;
    }
    if(flag > 0){
         p->next = (struct ListNode*)malloc(sizeof(struct ListNode));
            p->next->val = flag;
            p->next->next = NULL;
    }
    return addres;
}

LeetCode【492】【构造矩形】：https://leetcode-cn.com/problems/construct-the-rectangle/
int* constructRectangle(int area, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int l = sqrt(area);
    while(area%l)
        l++;
    int w = area/l;
    res[0] = l>w?l:w;
    res[1] = l>w?w:l;
    return res;
}

LeetCode【344】【反转字符串】：https://leetcode-cn.com/problems/reverse-string/
void reverseString(char* s, int sSize){
    for(int i = 0;i<sSize/2;i++){
        char tmp = s[sSize-1-i];
        s[sSize-i-1]=s[i];
        s[i] = tmp;
    }
}

LeetCode【263】【丑数】：https://leetcode-cn.com/problems/ugly-number/
bool isUgly(int num){
    if(num<1)
        return false;
    if(1 == num)
        return true;
    while((num != 2) && (num != 3) && (num != 5)){
        if(num%2==0)
        num/=2;
        else if(num%3==0)
            num/=3;
        else if(num%5==0)
            num/=5;
        else
            return false;
    }
    return true;
}

LeetCode【283】【移动0】：https://leetcode-cn.com/problems/move-zeroes/
void moveZeroes(int* nums, int numsSize){
    int left = 0,right = left;
    while(right<numsSize){
        while(left < numsSize - 1  && nums[left] != 0)
            left++;
        right = left + 1;
        while(right < numsSize && nums[right] == 0)
            right++;
        if(right<numsSize){
            nums[left] = nums[right];
            nums[right] = 0;
            left++;
        }
    }
}