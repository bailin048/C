LeetCode【1】:https://leetcode-cn.com/problems/two-sum/
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int left = 0;
    int right = 0;
    *returnSize = 2;
    int *res = (int *)malloc(sizeof(int)*2);
    for(left = 0;left<numsSize-1;left++){
        for(right=left+1;right<numsSize;right++){
           if(target - nums[left] == nums[right] )
           {
               res[0] = left,res[1] = right;
               return res; 
           }
        }
    }
    return res;
}

LeetCode【27】：https://leetcode-cn.com/problems/remove-element/
int removeElement(int* nums, int numsSize, int val){
    int k = 0,i;
	for (i = 0; i < numsSize; i++) {
		if (nums[i] != val) { //不等的数字覆盖
			nums[k++] = nums[i];
		}
	}
	return k;
}

LeetCode【709】:https://leetcode-cn.com/problems/to-lower-case/
char * toLowerCase(char * str){
    int len = strlen(str);      
    char* dst = (char*)malloc(len + 1);
    char* st = dst;   //保存起始位置
    if (NULL != dst) {
        memset(dst, '\0', len + 1); 
        while (*str) {
            if ((*str >= 'A') && (*str <= 'Z')) {  //只将大写转小写
                *dst = *str + 32;
            }
            else {
                *dst = *str;
            }
            str++;
            dst++;
        }
    }
    return st;
}

LeetCode【189】:https://leetcode-cn.com/problems/rotate-array/
void Reverse(int* nums, int start, int end)
{
    while (start < end) {
        int tmp = nums[end];
        nums[end] = nums[start];
        nums[start] = tmp;
        end--, start++;
    }
}
void rotate(int* nums, int numsSize, int k){
    k %= numsSize;
    Reverse(nums, 0, numsSize - 1);
    Reverse(nums, 0, k - 1);
    Reverse(nums, k, numsSize - 1);
}

LeetCode【35】:https://leetcode-cn.com/problems/search-insert-position/
int searchInsert(int* nums, int numsSize, int target){
    int left = 0;
	int right = numsSize - 1;
	int mid, flag;
	while (left <= right) {
		mid = (left + right) / 2;
		if (nums[mid] > target) {
			right = mid - 1;
			flag = 0; //说明:最后一次right减小引发的循环条件不满足,此时target>nums[right]
		}
		else if (nums[mid] < target) {
			left = mid + 1;
			flag = 1;//说明:最后一次left增大引起的循环条件不满足,此时target<nums[left]
		}
		else {
			return mid;//target存在与nums中且被找到
		}
	}
	return  flag == 0 ? right + 1 : left; //target比nums[left-1]大，但比nums[left]小，所以插的位置就是left
}

LeetCode【383】:https://leetcode-cn.com/problems/ransom-note/
bool canConstruct(char* ransomNote, char* magazine) {
    int num1[26] = {0};
    int num2[26] = {0};
    int k1 = strlen(ransomNote);
    int k2 = strlen(magazine);
    for(int i=0;i<k1;i++){
        num1[ransomNote[i]-'a']++;
    }
    for(int i=0;i<k2;i++){
        num2[magazine[i]-'a']++;
    }
    for(int i = 0;i<26;i++){
        if(num1[i]>num2[i]){
            return false;
        }
    }
    return true;
}

LeetCode【9】:https://leetcode-cn.com/problems/palindrome-number/
int LenofNum(int x)
{
    int cnt = 1;
    while (x /= 10) {
        cnt++;
    }
    return cnt;
}
int isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) { //负数及个位为0的非0数必不是回文数
        return false;
    }
    int k = LenofNum(x);
    for (int i = 0; i < k / 2; i++) {//计算一半就行
        int h = x / (int)pow(10, k - i - 1) % 10;  //获取高位数字
        int l = x / (int)pow(10, i) % 10;//获取低位数字
            if (h != l) {
                return false;
            }
    }
    return true;
}

LeetCode【58】:https://leetcode-cn.com/problems/length-of-last-word/
int lengthOfLastWord(char * s){
   int len = strlen(s), lastWordLen = 0;
    if (len == 0) return 0;

    for (int i = len - 1; i >= 0; i--) {
        if (s[i] != ' ') lastWordLen++;
        if (s[i] == ' ' && lastWordLen > 0) break;
    }

    return lastWordLen;
}

LeetCode【88】:https://leetcode-cn.com/problems/merge-sorted-array/
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    m--;
    n--; 
    for (int t = nums1Size - 1; t >= 0 && n >= 0 ; t--) {
        if (m < 0) { 
            nums1[t] = nums2[n--];
        }
        else{
            nums1[t] = nums2[n] > nums1[m] ? nums2[n--] : nums1[m--];
        }
    }
}

LeetCode【217】:https://leetcode-cn.com/problems/contains-duplicate/
int Cmp(const void* a,const void* b)
{
    return *(int*)a-*(int*)b;
}
bool containsDuplicate(int* nums, int numsSize){
    if(numsSize<=1)
        return false;
    else{
        qsort(nums,numsSize,sizeof(int),Cmp);
        for(int i = 0;i<numsSize-1;i++){
            if(nums[i]==nums[i+1])
            return true;
        }
    }
    return false;
}

LeetCode【925】:https://leetcode-cn.com/problems/long-pressed-name/
bool isLongPressedName(char * name, char * typed){
    int n = strlen(name);
    int m = strlen(typed);
    int i=0,j=0;
     while (j < m) {
        if (i < n && name[i] == typed[j]) {//一样则同时后移
            i++;
            j++;
        } else if (j > 0 && typed[j] == typed[j - 1]) {//不一样，但属于长按导致1
            j++;
        } else {//不对
            return false;
        }
    }
    return i == n;
}

LeetCode【977】:https://leetcode-cn.com/problems/squares-of-a-sorted-array/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    int* p =(int*)malloc(sizeof(int)*numsSize);
    int end = numsSize - 1;
    int start = 0;
    int i = end;
    while(start<=end){
        if(abs(nums[start])>=abs(nums[end]))
            p[i--] = pow(nums[start++],2);
        else
            p[i--] = pow(nums[end--],2);
    }
    *returnSize = numsSize;
    return p;
}

LeetCode【917】:https://leetcode-cn.com/problems/reverse-only-letters/
char * reverseOnlyLetters(char * S){
        int len = strlen(S);
    if (len <= 1)
        return S;
    char* str = (char*)malloc(len + 1);
    str[len] = '\0';
    char* stack = (char*)malloc(len + 1);
    int top = 0;
    int i = 0;
    while (i < len) {
        if (isalpha(S[i])) {
            stack[top++] = S[i];
        }
        i++;
    }
    i = 0;
    while (i < len) 
        str[i++] = isalpha(S[i]) ? stack[--top] : S[i];
    return str;
}

LeetCode【905】:https://leetcode-cn.com/problems/sort-array-by-parity/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortArrayByParity(int* A, int ASize, int* returnSize) {
    int left = 0;
    int right = ASize - 1;
    while (left <= right) {
        while (left<=right && !(A[left] % 2))
            left++;
        while (left<=right && A[right] % 2)
            right--;
        if (left <= right) {
            int tmp = A[left];
            A[left] = A[right];
            A[right] = tmp;
        }
    }
    *returnSize = ASize;
    return A;
}
LeetCode【724】:https://leetcode-cn.com/problems/find-pivot-index/
int pivotIndex(int* nums, int numsSize) {
    int sum = 0;
    int sumleft = 0;
    for (int i = 0; i < numsSize; i++) 
        sum += nums[i];
    for(int i = 0;i<numsSize;i++){
        if(2*sumleft+nums[i]==sum)
            return i;
        sumleft+=nums[i];
    }
    return -1;
}

LeetCode【66】:https://leetcode-cn.com/problems/plus-one/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* plusOne(int* digits, int digitsSize, int* returnSize){
    int * res = (int *)malloc(sizeof(int)*(digitsSize+1));
    int flag = 0;
    res[0] = 0;
    for(int i = digitsSize - 1;i>=0;i--){
        if(i==digitsSize - 1)
            res[i+1] = digits[i] + 1;
        else
            res[i+1] = digits[i]+flag;
        res[i+1]>9?(res[i+1]%=10,flag = 1):(res[i+1],flag=0);
    }
    res[0]+=flag;
    *returnSize = res[0]==0?digitsSize:digitsSize+1;
    return res[0]==0?res+1:res;
}

LeetCode【414】:https://leetcode-cn.com/problems/third-maximum-number/
int thirdMax(int* nums, int numsSize){
    if(1 == numsSize)
        return nums[0];
    else if(2 == numsSize)
        return nums[0]>nums[1]?nums[0]:nums[1];
    else{
        long first = LONG_MIN,second = LONG_MIN,third = LONG_MIN;
        for(int i = 0;i<numsSize;i++){
            if(nums[i]==third||nums[i]==second||nums[i]==first)
                continue;
            if(nums[i]>first){
                third = second;
                second = first;
                first = nums[i];
            }else if(nums[i]>second&&nums[i]<first){
                third = second;
                second = nums[i];
            }else if(nums[i]>third&&nums[i]<second)
                third = nums[i];
        }     
        return third==LONG_MIN?first:third;
    }
}

LeetCode【8】【字符串转数字】：https://leetcode-cn.com/problems/string-to-integer-atoi/
int myAtoi(char * s){
	char *ptr = s;
    int flag = 1;
    long int res = 0;
    while((*ptr) == ' ')
        ptr++;
    if(*ptr == '-'){
        flag = -1;
        ptr++;
    }else if(*ptr == '+'){
        flag = 1;
        ptr++;
    }
    while(isdigit(*ptr)){
        res=(res*10+*ptr-'0');
        if((int)res != res)
            break;
        ptr++;
    }
    if(isdigit(*ptr))
        if(flag == -1)
            return INT_MIN;
        else
            return INT_MAX;
    return res*flag;
}

LeetCode【34】【寻找目标数字的索引】：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
int* searchRange(int* nums, int numsSize, int target, int* returnSize){
    *returnSize = 2;
    int* res =(int*)malloc(sizeof(int)*2);
    res[0]=res[1]=-1;
    int left = 0,right = numsSize - 1;
    while(left<=right){//先找到target
        int mid = (left+right)>>1;
        if(nums[mid]>target)
            right = mid - 1;
        else if(nums[mid]<target)
            left = mid + 1;
        else{
            left = right = mid;//向两边找
            while(left - 1>=0 && !(nums[left-1]^target))
                left--;
             while(right + 1<=numsSize - 1 && !(nums[right+1]^target))
                right++;
            res[0] = left,res[1] = right;
            break;
        }
    }
    return res;
}

LeetCode【125】【验证回文字符串】:https://leetcode-cn.com/problems/valid-palindrome/
bool isPalindrome(char * s){
    int n = strlen(s);
    int left = 0;
    int right = n-1;
    while(left<=right){
        if(!isalnum(s[left])){
            left++;
            continue;
        }
        while(!isalnum(s[right])){
            right--;
            continue;
        }
        if(tolower(s[left]) != tolower(s[right]))
            return false;
        left++,right--;
    }
    return true;
}

LeetCode【443】【压缩字符串】：https://leetcode-cn.com/problems/string-compression/
static int _len(int k)
{
    int cnt = 1;
    while(k/=10)
        cnt++;
    return cnt;
}
int compress(char* chars, int charsSize){
    if(charsSize<2)//不需要压缩
        return charsSize;
    int follow = 0;
    int pre = 0;
    int t = 0;
    while(pre<charsSize){
        while(pre<charsSize&&chars[follow]==chars[pre])//出此循环说明pre已到下一个字符
            pre++;
        chars[t] = chars[follow];//将字符填入
        t++;
        int k = pre - follow;//计算与chars[follow]相同字符的数目
        int nums = _len(k);//获取k的位数
        while(k>1&&nums)//只有个数大于1才能填入计数
            chars[t++] = k/(int)pow(10,--nums)%10+'0';//分数位填入
        if(pre<charsSize)//字符数组未遍历完
            follow = pre;
        else //遍历完
            break;
    }
    return t;
}
LeetCode【150】【根据逆波兰表示法，求表达式的值】：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
int evalRPN(char ** tokens, int tokensSize){
    int* stack = (int*)malloc(tokensSize*sizeof(int));
    int top = -1;
    int n1 = 0,n2 = 0;
    for(int i = 0;i<tokensSize;i++){
        if(!strcmp(tokens[i],"+")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 + n2; 
        }
        else if(!strcmp(tokens[i],"*")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n1 * n2; 
        }    
        else if(!strcmp(tokens[i],"-")){
            n1 = stack[top--],n2 = stack[top--];
            stack[++top] = n2 - n1; 
        }     
        else if(!strcmp(tokens[i],"/")){
             n1 = stack[top--],n2 = stack[top--];
             stack[++top] = n2 / n1; 
        }
        else
            stack[++top] = atoi(tokens[i]);//字符转数字
    }
    return stack[top];
}

LeetCode【38】【外观数列】：https://leetcode-cn.com/problems/count-and-say/
char * countAndSay(int n){
    int size = 10000;
    char* strold = (char*)malloc(size);
    char* strnew = (char*)malloc(size);
    memset(strold,'\0',size),memset(strnew,'\0',size);
    strold[0] = '1';
    int cnt = 0;
    int k = 0;
    char *ptr = strold;
    while(--n){
        while(*ptr){
            cnt = 0;
            char key = *ptr;
            while(*ptr && *ptr == key)
                cnt++,ptr++;
            strnew[k++] = cnt + '0';
            strnew[k++] = key;
        }
        memcpy(strold,strnew,strlen(strnew));
        memset(strnew,'\0',strlen(strnew));
        ptr = strold;
        k = 0;
    }
    return strold;
}

【剑指Offer21】【调整数组顺序使奇数位于偶数之前】：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/
int* exchange(int* nums, int numsSize, int* returnSize){
    int left = 0,right = numsSize - 1;
    *returnSize = numsSize;
    while(left < right){
        while(left < right && nums[left]%2)
            left++;
        while(right>left && !(nums[right]%2))
            right--;
        int tmp = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
    }
    return nums;
}

LeetCode【167】【两数之和】：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(2*sizeof(int));
    res[0]=-1,res[1]=-1;
    int left = 0,right = numbersSize - 1;
    while(left<right){
        if(numbers[left]+numbers[right]>target)
            right--;
        else if(numbers[left]+numbers[right]<target)
            left++;
        else{
            res[0]=left+1,res[1]=right+1;
            break;
        }
    }
    return res;
}

LeetCode【168】【Excel表列名称】：https://leetcode-cn.com/problems/excel-sheet-column-title/
char * convertToTitle(int n){
    int size = 10000;
    char* res = (char*)malloc(size);
    int i = 0;
    memset(res,'\0',size);
    while(n){
        n-=1;
        int c = n%26;
        res[i++] = c  + 'A';
        n/=26;
    } 
    int len = strlen(res);
    int half = len/2;
    i = 0;
    while(i<half){
        char tmp = res[len - i - 1];
        res[len - i - 1] = res[i];
        res[i] = tmp;
        i++;
    }
    return res;
}

LeetCode【171】【Excel表列序号】：https://leetcode-cn.com/problems/excel-sheet-column-number/
int titleToNumber(char * s){
    int res = 0;
    int len = strlen(s);
    int i = len - 1;
    while(i > -1){
        res += (int)(*s - 64)*(int)pow(26,i);
        s++;
        i--;
    }
    return res;
}

LeetCode【112】【路径总和】：https://leetcode-cn.com/problems/path-sum/
bool IsEuqal(struct TreeNode* root,int target,int sum){
    if(NULL == root)
        return false;
    sum += root->val;
    if(sum == target && root->left == NULL && root->right == NULL)
        return true;
    return IsEuqal(root->left,target,sum) || IsEuqal(root->right,target,sum);
}
bool hasPathSum(struct TreeNode* root, int targetSum){
    int sum = 0;
    return IsEuqal(root,targetSum,0);
}

LeetCode【121】【买卖股票的最佳时机I】：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int buy = 0;
    int profit =0;
    int i = 0;
    while(i < pricesSize){
        buy = prices[i]<prices[buy]?i:buy;
        profit = profit>(prices[i]-prices[buy])?profit:prices[i]-prices[buy];
        i++;
    }
    return profit;
}

LeetCode【122】【买卖股票的最佳时机II】
int maxProfit(int* prices, int pricesSize){
    if(1 == pricesSize)
        return 0;
    int profit = 0;
    for(int i = 1;i<pricesSize;i++){
        profit += fmax(0,prices[i]-prices[i-1]);
    }
    return profit;
}

LeetCode【258】【各位相加】：https://leetcode-cn.com/problems/add-digits/
int addDigits(int num){
    if(num < 10)
        return num;
    else{
        int res = 0;
        while(num){
            res += (num%10);
            num/=10;
        }
        num = addDigits(res);
        return num; 
    }
}

【剑指Offer58-II】【左旋转字符串】：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/
char* reverseLeftWords(char* s, int n){
    int len = strlen(s);
    char* res = (char*)malloc(len + 1);
    char* p = res;
    memset(res,'\0',len + 1);
    n = n % len;
    char* tmp = s + n;
    strcpy(p,tmp);
    while(*p)
        p++;
    while(n--){
        *p = *s;
        s++,p++;
    }
    return res;
}

【剑指Offer28】【对称的二叉树】：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
bool _Issymmetric(struct TreeNode* p,struct TreeNode* q)
{
    if(NULL == p && NULL == q)
        return true;
    if(NULL == p || NULL == q)
        return false;
    return (p->val == q->val) && _Issymmetric(p->left,q->right) && _Issymmetric(p->right,q->left);
}
bool isSymmetric(struct TreeNode* root){
    if(NULL == root)
        return true;
    return _Issymmetric(root->left,root->right);
}

【剑指Offer52】【两个链表的第一个公共节点】：https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode* A = headA;
    struct ListNode* B = headB;
    while(A != B){
        if(A == NULL)
            A = headB;
        else
            A = A->next;
        if(B == NULL)
            B = headA;
        else
            B = B->next;
    }
    return A;
}

【剑指Offer26】【树的子结构】：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
bool IsSame(struct TreeNode* p,struct TreeNode* q){
    if(q == NULL)
        return true;
    if(p == NULL)
        return false;
    return (p->val == q->val) && IsSame(p->left,q->left) && IsSame(p->right,q->right);
}
bool isSubStructure(struct TreeNode* A, struct TreeNode* B){
    if(A == NULL || B == NULL)
        return false;
    if(IsSame(A,B))
        return true;
    return isSubStructure(A->left,B) || isSubStructure(A->right,B);
}

【剑指offer22】【链表中倒数第K个节点】：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
【方法1】
int LenofList(struct ListNode* head){
    int n = 0;
    while(head){
        head = head->next;
        n++;
    }
    return n;
}
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    int len = LenofList(head);
    if(k > len)
        return NULL;
    while(len != k){
        head = head->next;
        len--;
    }
    return head;
}
【方法2】：双指针
struct ListNode* getKthFromEnd(struct ListNode* head, int k){
    struct ListNode* pre = head;
    while(k && pre != NULL){
        pre = pre->next;
        k--;
    }
    while(pre != NULL){
        pre = pre->next;
        head = head->next;
    }
    return k==0?head:pre;
}

【LCP01】【猜数字】：https://leetcode-cn.com/problems/guess-numbers/
int game(int* guess, int guessSize, int* answer, int answerSize){
    int cnt = 0;
    for(int i = 0;i<guessSize;i++)
       cnt += (guess[i]==answer[i]?1:0);
    return cnt;
}

【LCP18】【早餐组合】：https://leetcode-cn.com/problems/2vYnGI/
void ShellInsert(int *a,int dk,int size){
    for(int i = dk;i < size;i++){
        int temp = a[i];
        int j = 0;
        for(j = i - dk;j >= 0 && temp < a[j];j-=dk)
            if(temp < a[j])
                a[j+dk] = a[j];
        a[j+dk] = temp;
    }
}
void Sort(int* a,int size){
    int dk = size;
    while(dk/=2)
        ShellInsert(a,dk,size);
}
int breakfastNumber(int* staple, int stapleSize, int* drinks, int drinksSize, int x){
   Sort(drinks,drinksSize);
   int cnt = 0;
   for(int i = 0;i < stapleSize; i++){
        int left = 0,right = drinksSize - 1,mid = 0;
        while(left <= right){
            mid = (left+right)>>1;
            int tmp = staple[i]+drinks[mid];
            if(tmp>x)
                right = mid - 1;
            else
                left = mid + 1;
        }
        cnt += left;
        cnt %= 1000000007; 
   }
   return cnt;
}

LeetCode【107】【二叉树的层序遍历】：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
int Height(struct TreeNode* root){
     if(NULL == root)
        return 0;
    int h_l = Height(root->left) + 1;
    int h_r = Height(root->right) + 1;
    return h_l>h_r?h_l:h_r; 
 }
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
        if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = Height(root);//树深
    int** levelorder = (int**)malloc(sizeof(int*)*h);//开辟空间，存储数组指针
    *returnSize = h;//数组指针的数目 = 树深
    *returnColumnSizes =  (int *)malloc(sizeof(int)*h);//
    
    struct TreeNode*q1[1000],*q2[1000];
    int q1_size = 0,q2_size = 0;
    q1[0] = root;
    q1_size++;
    int level = 0;
    while(level<h){
        levelorder[h-1-level] = (int *)malloc(sizeof(int)*q1_size);
        for(int i = 0;i<q1_size;i++)
            levelorder[h-1-level][i] = q1[i]->val;
        (*returnColumnSizes)[h-1-level] = q1_size;
        for(int i = 0;i<q1_size;i++){//q1里的左右孩子存入q2，获得下一层数据
            if(q1[i]->left != NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right != NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode*)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        level++;
    }
    return levelorder;
}

LCP【16】【速算机器人】：https://leetcode-cn.com/problems/nGK0Fy/
int calculate(char* s){
    int x = 1,y = 0;
    while(*s){
        if(*s == 'A')
            x = 2*x + y;
        else
            y = 2*y + x;
        s++;
    }
    return x+y;
}

LCP【11】【期望个数统计】：https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji/
void Sort(int* scores,int num){
    int dk = num;
    while(dk/=2){
        for(int i = dk;i<num;i++){
            int tmp = scores[i];
            if(tmp<scores[i-dk]){
                int j = 0;
                for(j=i-dk;j>=0&&tmp<scores[j];j-=dk)
                    scores[j+dk]=scores[j];
                scores[j+dk] = tmp;
            }
        }
    }
}
int expectNumber(int* scores, int scoresSize){
    int cnt = 1;
    Sort(scores,scoresSize);
    for(int i = 1;i<scoresSize;i++){
        if(scores[i]!=scores[i-1])
            cnt+=1;
    } 
    return cnt;
}

LCP【06】【拿硬币】：https://leetcode-cn.com/problems/na-ying-bi/
int minCount(int* coins, int coinsSize){
    int cnt = 0;
    for(int i = 0;i<coinsSize;i++)
        cnt += coins[i]%2?(coins[i]/2+1):(coins[i]/2);
    return cnt;
}

LCP【02】【分式化简】：https://leetcode-cn.com/problems/deep-dark-fraction/
int* fraction(int* cont, int contSize, int* returnSize){
    *returnSize = 2;
    int* res = (int*)malloc(sizeof(int)*2);
    int son = 1; //最后一分数，分子为1
    int mother = cont[contSize-1];//分母为数组最后一个元素
    int tmp = 0;//提供交换功能
    for(int i = contSize - 2;i>=0;i--){
        tmp = mother;//保存上次分母
        mother = mother*cont[i]+son;//计算新分母
        son = tmp;//分子继承tmp
    }
    res[0] = mother;//因为数组首元素计算完成后未发生分子分母交换,此处存储时反序即可
    res[1] = son;
    return res;
}

【剑指offer15】【二进制中1的个数】https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
int hammingWeight(uint32_t n) {
    int cnt = 0;
    for(int i = 0;i<32;i++){
        if((n>>i)&1)
            cnt++;
    }
    return cnt;
}

【剑指offer17】：打印从1到最大的n位数
int* printNumbers(int n, int* returnSize){
    int max = pow(10,n) - 1;
    *returnSize = max;
    int* res = (int*)malloc(sizeof(int)*max);
    for(int i = 0;i < max;i++)
        res[i] = i + 1;
    return res;
}

【LCP22】【黑白方格画】：https://leetcode-cn.com/problems/ccw6C7/
int factorail(int n,int m){
    int son = 1,mother = 1; 
    for(int k = n;k>n-m;k--)
        son*=k;
    for(int k = 1;k<=m;k++)
        mother*=k;
    return son/mother;
}
int paintingPlan(int n, int k){
    if(k==n){
        if(k==1)//n=k=1
            return 1;
        else//n==k!=1
            return 2*n;
    }
    if(k==n*n || k==0)//白板或者黑板
        return 1;
    if(k<n)//一行都画不满，不让进循环，否则浪费空间时间
        return 0;
    int cnt = 0;
    for(int i = 1;i<n;i++){
        int res = k - i*n;
        if(res>0){
            int flag = res%(n-i)==0?res/(n-i)<n?res/(n-i):0:0;
            if(flag)
                cnt+=factorail(n,i)*factorail(n,flag);
        }
        else if(res == 0)
            cnt += 2*factorail(n,i);
        else
            continue;
    }
    return cnt;
}

【剑指Offer18】【删除链表的节点】：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
struct ListNode* deleteNode(struct ListNode* head, int val){
    if(NULL == head)
        return head;
    struct ListNode* p = head;
    struct ListNode* pre = NULL;
    while(p){
        if(p->val == val && p == head)
            head = p->next;
        else if(p->val == val)
            pre->next = p->next;
        pre = p;
        p=p->next;
    }
    return head;
}

【剑指offer27】【二叉树的镜像】：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
struct TreeNode* mirrorTree(struct TreeNode* root){
    if(NULL == root)
        return NULL;
    struct TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = tmp;
    mirrorTree(root->left);
    mirrorTree(root->right);
    return root;
}

【剑指offer32】【从上到下打印二叉树】：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
int height(struct TreeNode* root){
    if(NULL == root)
        return 0;
    int h_l = height(root->left)+1;
    int h_r = height(root->right)+1;
    return h_l>h_r?h_l:h_r;
 }
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    if(NULL == root){
        *returnSize = 0;
        return NULL;
    }
    int h = height(root);
    int** res = (int**)malloc(sizeof(int*)*h);
    *returnSize = h;
    *returnColumnSizes = (int*)malloc(sizeof(int)*h);

    struct TreeNode* q1[1000],*q2[1000];
    int q1_size =0,q2_size=0;
    q1[0]=root;
    q1_size++;
    int layer = 0;
    while(layer<h){
        res[layer] = (int*)malloc(sizeof(int)*q1_size);
        for(int i= 0;i<q1_size;i++)
            res[layer][i] = q1[i]->val;
        (*returnColumnSizes)[layer] = q1_size;
        for(int i = 0;i<q1_size;i++){
            if(q1[i]->left!=NULL)
                q2[q2_size++] = q1[i]->left;
            if(q1[i]->right!=NULL)
                q2[q2_size++] = q1[i]->right;
        }
        memcpy(q1,q2,sizeof(struct TreeNode *)*q2_size);
        q1_size = q2_size;
        q2_size = 0;
        layer++;
    }
    return res;
}

【剑指offer42】:最大子序和
int maxSubArray(int* nums, int numsSize){
    int submax = nums[0];
    int max = nums[0];
    for(int i= 1;i<numsSize;i++){  
        if(submax<0)
            submax = nums[i];
        else  
            submax += nums[i];
        max = submax>max?submax:max; 
    }
    return max;
}

【LeetCode151】【剑指offer58】【翻转单词顺序】：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/
int len = strlen(s);
    if (len == 0)
        return s;
    char* res = (char*)malloc(len + 1);
    memset(res, ' ', len + 1);
    int i = len;
    char* pre = s;
    char* help = NULL;
    char* target = NULL;
    while (*pre) {
        while (*pre && *pre == ' ')//跳空格
            pre++;
        help = pre;//help指向单词首字母
        while (*pre && *pre != ' ')
            pre++;
        target = pre;//target指向单词右侧
        if (*pre == '\0') {//最后一个单词，pre会指向'\0'
            res[i--] = ' ';
            pre--;
        }
        while (help-1 != pre) {//后退式复制带空格
            res[i--] = *pre;
            pre--;
        }
        pre = target;//复制完成pre回到空格处，寻找下一个单词
    }
    res[len] = '\0';//原本此处被放空格
    while (*res == ' ')
        res++;
    return res;
}

LeetCode【202】【快乐数】:https://leetcode-cn.com/problems/happy-number/
int helper(int n){
    int res = 0;
    while(n){
        int tmp = n%10;
        res += tmp*tmp;
        n/=10;
    }
    return res;
}
bool isHappy(int n){
    int slow = n,fast = n;
    do{
        slow = helper(slow);
        fast = helper(helper(fast));
    }while(slow!=fast);
    return slow==1;
}
